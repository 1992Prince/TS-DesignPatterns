🧩 Explanation of the Example — Open/Closed Principle in Action
🔹 Problem Recap (Before OCP)

Earlier we had function or class:

function giveDiscount(customerType: "regular" | "premium"): number { ... }


Every time a new customer type (vvip, gold, etc.) was added,
➡️ we had to modify the function — breaking OCP.

🔹 Objective

“Make the system open for extension (we can add new customer types)
but closed for modification (no need to edit existing tested code).”

🔹 How this Code Achieves It

Interface defines abstraction (contract)

interface Customer {
    giveDiscount(): number;
}


This ensures every customer class must provide its own discount rule.

The system doesn’t care which type of customer — just that it implements giveDiscount().

Concrete implementations for each customer type

class RegularCustomer implements Customer {
    giveDiscount(): number { return 10; }
}

class PremiumCustomer implements Customer {
    giveDiscount(): number { return 20; }
}


Each class encapsulates its logic.

Adding a new type = just add a new class (e.g. VVIPCustomer) that implements Customer.

✅ No existing code changes.

Abstraction layer (CustomerDiscount) uses the interface

class CustomerDiscount {
    giveDiscount(customer: Customer): number {
        return customer.giveDiscount();
    }
}


Notice: this class depends on the abstraction (interface), not the concrete types.

This is the key — it works for any Customer.

Usage

let regularCust = new RegularCustomer();
let custDiscount = new CustomerDiscount();
console.log(custDiscount.giveDiscount(regularCust)); // 10


Works for Regular, Premium, or any new type that implements Customer.

💡 Interview Talking Points
| Principle                   | How your code follows it                                                                              |
| --------------------------- | ----------------------------------------------------------------------------------------------------- |
| **Open for extension**      | You can add new customer types (like `VVIPCustomer`) by creating new classes implementing `Customer`. |
| **Closed for modification** | You don’t modify `CustomerDiscount` or existing classes. They stay untouched and stable.              |
| **Abstraction**             | The interface `Customer` acts as a contract for all types.                                            |
| **Polymorphism**            | `CustomerDiscount.giveDiscount()` calls the correct implementation dynamically at runtime.            |
| **Single Responsibility**   | Each class handles only one responsibility — its own discount logic.                                  |

🚀 Real-World Analogy

Think of your CustomerDiscount class like a payment gateway:

It doesn’t care which payment method (Card, UPI, PayPal).

It only calls the pay() method defined in the interface.

Add new payment type → just implement the interface.

Same idea here — CustomerDiscount never changes.

🧠 Summary (30-sec Interview Answer)

“In this example, Customer is an interface defining the discount behavior.
RegularCustomer and PremiumCustomer implement it separately.
The CustomerDiscount class uses the Customer abstraction, not concrete types.
So when a new customer type like VVIPCustomer is introduced, I only create a new class — I never modify existing logic.
That’s exactly the Open/Closed Principle — open for extension, closed for modification.”




🧠 Developer-Level Understanding

You said:

“As a developer, I’ll only expose CustomerDiscount to others.
They’ll just create a RegularCustomer or PremiumCustomer object and pass it to CustomerDiscount.
They shouldn’t know or care how those classes are implemented.”

That’s exactly the purpose of abstraction — and it’s a design principle used everywhere (frameworks, SDKs, APIs, test frameworks).

🔹 What’s Really Happening
✅ 1. You’re Exposing Only the Contract — Not the Implementation

Other developers only need to know:

Customer (interface)

CustomerDiscount (the class that accepts a Customer)

They don’t need to see the code inside RegularCustomer or PremiumCustomer — only how to instantiate them.

So their usage code looks like:

let discountService = new CustomerDiscount();
let discount = discountService.giveDiscount(new PremiumCustomer());


They only interact with public contracts, not with private implementations.

✅ 2. You’re Hiding Implementation Details (Encapsulation)

The internal logic of RegularCustomer and PremiumCustomer — i.e., how they calculate discount — is hidden.

If tomorrow you change PremiumCustomer’s logic (say from flat 20% to dynamic based on order value),
➜ No one outside needs to change their code.

This is encapsulation — you hide the “how” and expose only the “what”.

✅ 3. You’re Enforcing Loose Coupling

CustomerDiscount depends on the interface Customer, not on RegularCustomer or PremiumCustomer.

So your CustomerDiscount class never needs to be recompiled, retested, or changed when a new customer type appears.

➡️ This is Loose Coupling — achieved via Abstraction + Polymorphism.

✅ 4. You’re Following the “Plug-and-Play” Model

This design makes your module behave like a plug socket —
any Customer type can plug into it, and CustomerDiscount just works.

You’ve basically built a plugin architecture at a small scale.

🧩 How You’d Explain This in an Interview

“I’ve designed CustomerDiscount to depend only on the Customer abstraction.
This hides all implementation details of specific customers.
A consuming developer just needs to create a customer object (regular or premium) and pass it — they never worry about how the discount is calculated internally.
This enforces encapsulation, loose coupling, and follows the Open/Closed Principle.
Adding a new customer type means just adding a new implementation — not modifying existing code.”