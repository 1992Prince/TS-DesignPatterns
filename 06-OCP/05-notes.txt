ğŸ§© Explanation of the Example â€” Open/Closed Principle in Action
ğŸ”¹ Problem Recap (Before OCP)

Earlier we had function or class:

function giveDiscount(customerType: "regular" | "premium"): number { ... }


Every time a new customer type (vvip, gold, etc.) was added,
â¡ï¸ we had to modify the function â€” breaking OCP.

ğŸ”¹ Objective

â€œMake the system open for extension (we can add new customer types)
but closed for modification (no need to edit existing tested code).â€

ğŸ”¹ How this Code Achieves It

Interface defines abstraction (contract)

interface Customer {
    giveDiscount(): number;
}


This ensures every customer class must provide its own discount rule.

The system doesnâ€™t care which type of customer â€” just that it implements giveDiscount().

Concrete implementations for each customer type

class RegularCustomer implements Customer {
    giveDiscount(): number { return 10; }
}

class PremiumCustomer implements Customer {
    giveDiscount(): number { return 20; }
}


Each class encapsulates its logic.

Adding a new type = just add a new class (e.g. VVIPCustomer) that implements Customer.

âœ… No existing code changes.

Abstraction layer (CustomerDiscount) uses the interface

class CustomerDiscount {
    giveDiscount(customer: Customer): number {
        return customer.giveDiscount();
    }
}


Notice: this class depends on the abstraction (interface), not the concrete types.

This is the key â€” it works for any Customer.

Usage

let regularCust = new RegularCustomer();
let custDiscount = new CustomerDiscount();
console.log(custDiscount.giveDiscount(regularCust)); // 10


Works for Regular, Premium, or any new type that implements Customer.

ğŸ’¡ Interview Talking Points
| Principle                   | How your code follows it                                                                              |
| --------------------------- | ----------------------------------------------------------------------------------------------------- |
| **Open for extension**      | You can add new customer types (like `VVIPCustomer`) by creating new classes implementing `Customer`. |
| **Closed for modification** | You donâ€™t modify `CustomerDiscount` or existing classes. They stay untouched and stable.              |
| **Abstraction**             | The interface `Customer` acts as a contract for all types.                                            |
| **Polymorphism**            | `CustomerDiscount.giveDiscount()` calls the correct implementation dynamically at runtime.            |
| **Single Responsibility**   | Each class handles only one responsibility â€” its own discount logic.                                  |

ğŸš€ Real-World Analogy

Think of your CustomerDiscount class like a payment gateway:

It doesnâ€™t care which payment method (Card, UPI, PayPal).

It only calls the pay() method defined in the interface.

Add new payment type â†’ just implement the interface.

Same idea here â€” CustomerDiscount never changes.

ğŸ§  Summary (30-sec Interview Answer)

â€œIn this example, Customer is an interface defining the discount behavior.
RegularCustomer and PremiumCustomer implement it separately.
The CustomerDiscount class uses the Customer abstraction, not concrete types.
So when a new customer type like VVIPCustomer is introduced, I only create a new class â€” I never modify existing logic.
Thatâ€™s exactly the Open/Closed Principle â€” open for extension, closed for modification.â€




ğŸ§  Developer-Level Understanding

You said:

â€œAs a developer, Iâ€™ll only expose CustomerDiscount to others.
Theyâ€™ll just create a RegularCustomer or PremiumCustomer object and pass it to CustomerDiscount.
They shouldnâ€™t know or care how those classes are implemented.â€

Thatâ€™s exactly the purpose of abstraction â€” and itâ€™s a design principle used everywhere (frameworks, SDKs, APIs, test frameworks).

ğŸ”¹ Whatâ€™s Really Happening
âœ… 1. Youâ€™re Exposing Only the Contract â€” Not the Implementation

Other developers only need to know:

Customer (interface)

CustomerDiscount (the class that accepts a Customer)

They donâ€™t need to see the code inside RegularCustomer or PremiumCustomer â€” only how to instantiate them.

So their usage code looks like:

let discountService = new CustomerDiscount();
let discount = discountService.giveDiscount(new PremiumCustomer());


They only interact with public contracts, not with private implementations.

âœ… 2. Youâ€™re Hiding Implementation Details (Encapsulation)

The internal logic of RegularCustomer and PremiumCustomer â€” i.e., how they calculate discount â€” is hidden.

If tomorrow you change PremiumCustomerâ€™s logic (say from flat 20% to dynamic based on order value),
âœ No one outside needs to change their code.

This is encapsulation â€” you hide the â€œhowâ€ and expose only the â€œwhatâ€.

âœ… 3. Youâ€™re Enforcing Loose Coupling

CustomerDiscount depends on the interface Customer, not on RegularCustomer or PremiumCustomer.

So your CustomerDiscount class never needs to be recompiled, retested, or changed when a new customer type appears.

â¡ï¸ This is Loose Coupling â€” achieved via Abstraction + Polymorphism.

âœ… 4. Youâ€™re Following the â€œPlug-and-Playâ€ Model

This design makes your module behave like a plug socket â€”
any Customer type can plug into it, and CustomerDiscount just works.

Youâ€™ve basically built a plugin architecture at a small scale.

ğŸ§© How Youâ€™d Explain This in an Interview

â€œIâ€™ve designed CustomerDiscount to depend only on the Customer abstraction.
This hides all implementation details of specific customers.
A consuming developer just needs to create a customer object (regular or premium) and pass it â€” they never worry about how the discount is calculated internally.
This enforces encapsulation, loose coupling, and follows the Open/Closed Principle.
Adding a new customer type means just adding a new implementation â€” not modifying existing code.â€