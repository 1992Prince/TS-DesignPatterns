ğŸ§© UNION TYPES IN TYPESCRIPT

ğŸ§  Concept

A union type allows a variable, parameter, or return value to hold more than one possible type.

Think of it as:

â€œThis variable can be either of these types.â€

ğŸ“˜ Syntax
let value: TypeA | TypeB;

The | means type-level OR, not logical OR (||).



ğŸ”¹ 1ï¸âƒ£ Union Types with Primitive Types

Example:

let id: number | string;

id = 101;     // âœ… valid
id = "EMP45"; // âœ… valid
id = true;    // âŒ invalid (not part of union)


ğŸ’¡ Why use:

Sometimes APIs return either a number or string (e.g., an ID that can be numeric or alphanumeric).



ğŸ”¹ 2ï¸âƒ£ Union Types with Custom Types (Interfaces / Objects)

Example:

type Student = { name: string; grade: number; };
type Teacher = { name: string; subject: string; };

let person: Student | Teacher;

person = { name: "Rahul", grade: 9 };        // âœ… valid
person = { name: "Priya", subject: "Math" }; // âœ… valid
person = { name: "Raj" };                    // âŒ invalid


ğŸ’¡ The object must satisfy at least one complete type in the union.



ğŸ”¹ 3ï¸âƒ£ Union Types with Literal Values (String Literal Unions)

Example:

type Direction = "up" | "down" | "left" | "right";

function move(dir: Direction) {
  console.log("Moving " + dir);
}

move("up");    // âœ…
move("left");  // âœ…
move("north"); // âŒ not allowed


ğŸ’¡ Common in frameworks like Playwright, React, etc. â€” e.g.

waitUntil: "load" | "domcontentloaded" | "networkidle"


ğŸ”¹ 4ï¸âƒ£ Union Types with Mixed Values and Types

Example:

type Response = "success" | "error" | number;

let res: Response;

res = "success"; // âœ…
res = "error";   // âœ…
res = 404;       // âœ…
res = true;      // âŒ


ğŸ’¡ You can mix literal values, primitive types, and even objects.

ğŸ”¹ 5ï¸âƒ£ Narrowing Unions (Type Guards)

When you use a union, you must check its actual type before using type-specific operations.

Example:

function printId(id: number | string) {
  if (typeof id === "string") {
    console.log(id.toUpperCase()); // âœ… safe
  } else {
    console.log(id.toFixed(2)); // âœ… safe
  }
}


ğŸ’¡ This checking is called type narrowing â€” it helps TS infer the exact type during execution flow.

ğŸ”¹ 6ï¸âƒ£ Arrays with Union Types

Thereâ€™s a difference between:

let arr1: (number | string)[] = [1, "a", 2]; // âœ… elements can be both
let arr2: number[] | string[];               // âŒ either all numbers or all strings


ğŸ’¡ (number | string)[] â†’ mixed array
number[] | string[] â†’ homogeneous array (decide later which)

ğŸ”¹ 7ï¸âƒ£ Union Types in Function Parameters / Returns

Example:

function format(value: string | number): string {
  return typeof value === "string" ? value.toUpperCase() : value.toFixed(2);
}

console.log(format("hello")); // HELLO
console.log(format(123.456)); // 123.46




âš™ï¸ INSTALLATION â€” TS PROJECT VIA NPM

When you clone a TypeScript-based Node.js project (that has a package.json):

ğŸªœ Steps

1ï¸âƒ£ Open terminal in project root
(where you see package.json)

2ï¸âƒ£ Install all dependencies

npm install


âœ… This will create a node_modules folder and download everything from package.json.

3ï¸âƒ£ Verify installation

npx tsc --version


4ï¸âƒ£ Build or run
Check scripts in package.json and run accordingly:

npm run build      # compiles TS â†’ JS
npm run dev        # runs in watch/dev mode
npm start          # starts server/app


5ï¸âƒ£ (Optional) Initialize TS config (if not already present)

npx tsc --init


âœ… In short:

Union types = â€œeither-orâ€ types (| is type-level OR)

Great for making APIs safer and predictable

Commonly used with literal values (e.g. "regular" | "premium")

Install project dependencies with npm install