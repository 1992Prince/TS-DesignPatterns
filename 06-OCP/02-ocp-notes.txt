🧩 Open/Closed Principle (OCP)

🔹 Definition (Simple & Interview-Ready)

A class should be open for extension but closed for modification.

That means:

You should be able to add new functionality
➜ without changing existing tested code.

Instead of editing a class every time requirements change,
➜ you extend it (via inheritance, composition, or abstraction).

💡 Why it matters

    - In automation frameworks or large systems:
    - Frequent changes in business logic or test behaviors can break existing working modules.
    - Following OCP ensures stability, scalability, and fewer regressions.
    - Helps in plug-and-play design, where new features or test flows can be added easily.


🔹 Core idea

    - Don’t touch existing, tested classes.
    - Introduce new behavior by creating new classes or implementations of abstractions 
      (like interfaces or abstract classes).
    - Existing code should work the same, without any modification.




🔹 In Automation Frameworks

As an SDET Lead, you can say:

“In test automation, OCP helps us design framework modules like Reporting, Drivers, or Wait Utilities in a way 
that new features (like new report formats, browsers, or wait conditions) can be added without 
changing the core logic.”

Examples (conceptually):

Adding a new browser → implement a new DriverManager instead of modifying the existing one.

Adding a new report type → implement a new ReportGenerator class instead of editing the existing class.

Adding new test data sources → create a new DataProvider that implements the same interface.

🔹 Benefits

Benefit	Description
    ✅ Maintainability	Fewer changes = fewer bugs
    ✅ Extensibility	Add new features easily
    ✅ Stability	Existing tested code stays untouched
    ✅ Readability	Clear separation of responsibilities
    🚫 Common Violation

When developers edit existing classes every time a new feature or case appears (e.g., adding if-else or switch 
statements for every new condition), they break OCP.

Example conceptually:
Adding another “browser” or “report format” by inserting more if/else conditions inside an 
existing method instead of creating a new class.

That makes code harder to maintain and more bug-prone.

🔹 How to achieve OCP

| Technique                             | Purpose                                                |
| ------------------------------------- | ------------------------------------------------------ |
| Use **interfaces/abstract classes**   | Define contracts for extension                         |
| Use **polymorphism**                  | Call behavior dynamically                              |
| Use **dependency injection**          | Inject new implementations without changing the client |
| Use **composition over inheritance**  | Add new behavior via objects, not class edits          |
| Apply **strategy or factory pattern** | Plug in new algorithms or types dynamically            |


💬 Interview Summary Answer (Short 30-sec version)

“The Open/Closed Principle says that software entities like classes or modules 
should be open for extension but closed for modification.

It means we should design systems where we can add new behavior without changing existing code.

In automation, this ensures that when we add a new browser, report, or feature, we just extend or 
implement new classes — not touch the stable core logic. 

This leads to cleaner, 
maintainable, and less error-prone frameworks.”